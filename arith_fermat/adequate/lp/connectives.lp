require open coq.sttfa;
constant symbol True : Els (↑ (prop));
constant symbol False : Els (↑ (prop));
constant symbol Not : Els (↑ (prop ⇝ prop));
constant symbol And : Els (↑ (prop ⇝ prop ⇝ prop));
constant symbol Or : Els (↑ (prop ⇝ prop ⇝ prop));
constant symbol ex : Els (∀ₖ (λ A, ↑ ((A ⇝ prop) ⇝ prop)));
constant symbol equal : Els (∀ₖ (λ A, ↑ (A ⇝ A ⇝ prop)));
constant symbol I : Prf (True);
constant symbol falsity : Prf (`∀ t : El (prop), False ⇒ t);
constant symbol nmk : Prf (`∀ A : El (prop), (A ⇒ False) ⇒ (Not) ▪ A);
constant symbol Not_ind : Prf (`∀ A : El (prop), `∀ Q : El (prop), ((A ⇒ False) ⇒ Q) ⇒ ((Not) ▪ A) ⇒ Q);
constant symbol conj : Prf (`∀ A : El (prop), `∀ B : El (prop), A ⇒ B ⇒ ((And) ▪ A) ▪ B);
constant symbol match_And_prop : Prf (`∀ A : El (prop), `∀ B : El (prop), `∀ return_ : El (prop), (A ⇒ B ⇒ return_) ⇒ (((And) ▪ A) ▪ B) ⇒ return_);
constant symbol or_introl : Prf (`∀ A : El (prop), `∀ B : El (prop), A ⇒ ((Or) ▪ A) ▪ B);
constant symbol or_intror : Prf (`∀ A : El (prop), `∀ B : El (prop), B ⇒ ((Or) ▪ A) ▪ B);
constant symbol match_Or_prop : Prf (`∀ A : El (prop), `∀ B : El (prop), `∀ return_ : El (prop), (A ⇒ return_) ⇒ (B ⇒ return_) ⇒ (((Or) ▪ A) ▪ B) ⇒ return_);
constant symbol ex_intro : Prf (`∀ₚ A, `∀ P : El ((A ⇝ prop)), `∀ x : El (A), ((P) ▪ x) ⇒ ((ex) at (A)) ▪ P);
constant symbol match_ex_prop : Prf (`∀ₚ A, `∀ P : El ((A ⇝ prop)), `∀ return_ : El (prop), (`∀ x : El (A), ((P) ▪ x) ⇒ return_) ⇒ (((ex) at (A)) ▪ P) ⇒ return_);
constant symbol refl_equal : Prf (`∀ₚ A, `∀ x : El (A), (((equal) at (A)) ▪ x) ▪ x);
constant symbol equal_leibniz : Prf (`∀ₚ A, `∀ x : El (A), `∀ y : El (A), ((((equal) at (A)) ▪ x) ▪ y) ⇒ `∀ P : El ((A ⇝ prop)), ((P) ▪ x) ⇒ (P) ▪ y);
