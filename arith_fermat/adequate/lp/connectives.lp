require open coq.sttfa;
constant symbol True : Els (↑ (prop));
constant symbol False : Els (↑ (prop));
constant symbol Not : Els (↑ (prop ⇝ prop));
constant symbol And : Els (↑ (prop ⇝ prop ⇝ prop));
constant symbol Or : Els (↑ (prop ⇝ prop ⇝ prop));
constant symbol ex : Els (∀ₖ (λ A, ↑ ((A ⇝ prop) ⇝ prop)));
constant symbol equal : Els (∀ₖ (λ A, ↑ (A ⇝ A ⇝ prop)));
constant symbol I : Prf (True);
constant symbol falsity : Prf (∀ (λ t : El (prop), False ⇒ t));
constant symbol nmk : Prf (∀ (λ A : El (prop), (A ⇒ False) ⇒ app (Not) A ■));
constant symbol Not_ind : Prf (∀ (λ A : El (prop), ∀ (λ Q : El (prop), ((A ⇒ False) ⇒ Q) ⇒ (app (Not) A ■) ⇒ Q)));
constant symbol conj : Prf (∀ (λ A : El (prop), ∀ (λ B : El (prop), A ⇒ B ⇒ app (app (And) A ■) B ■)));
constant symbol match_And_prop : Prf (∀ (λ A : El (prop), ∀ (λ B : El (prop), ∀ (λ return_ : El (prop), (A ⇒ B ⇒ return_) ⇒ (app (app (And) A ■) B ■) ⇒ return_))));
constant symbol or_introl : Prf (∀ (λ A : El (prop), ∀ (λ B : El (prop), A ⇒ app (app (Or) A ■) B ■)));
constant symbol or_intror : Prf (∀ (λ A : El (prop), ∀ (λ B : El (prop), B ⇒ app (app (Or) A ■) B ■)));
constant symbol match_Or_prop : Prf (∀ (λ A : El (prop), ∀ (λ B : El (prop), ∀ (λ return_ : El (prop), (A ⇒ return_) ⇒ (B ⇒ return_) ⇒ (app (app (Or) A ■) B ■) ⇒ return_))));
constant symbol ex_intro : Prf (∀ₚ (λ A, ∀ (λ P : El ((A ⇝ prop)), ∀ (λ x : El (A), (app (P) x ■) ⇒ app (el-∀ₖ (ex) (A) ■) P ■))));
constant symbol match_ex_prop : Prf (∀ₚ (λ A, ∀ (λ P : El ((A ⇝ prop)), ∀ (λ return_ : El (prop), (∀ (λ x : El (A), (app (P) x ■) ⇒ return_)) ⇒ (app (el-∀ₖ (ex) (A) ■) P ■) ⇒ return_))));
constant symbol refl_equal : Prf (∀ₚ (λ A, ∀ (λ x : El (A), app (app (el-∀ₖ (equal) (A) ■) x ■) x ■)));
constant symbol equal_leibniz : Prf (∀ₚ (λ A, ∀ (λ x : El (A), ∀ (λ y : El (A), (app (app (el-∀ₖ (equal) (A) ■) x ■) y ■) ⇒ ∀ (λ P : El ((A ⇝ prop)), (app (P) x ■) ⇒ app (P) y ■)))));
